{"version":3,"file":"991.bundle.js","mappings":"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","sources":["webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/slicedToArray.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/classCallCheck.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/createClass.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","webpack://probi-oh/./src/utils/card-details.ts","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","webpack://probi-oh/./src/utils/card.ts","webpack://probi-oh/./node_modules/@babel/runtime/helpers/esm/inherits.js","webpack://probi-oh/./src/utils/deck.ts","webpack://probi-oh/./src/utils/parser.ts","webpack://probi-oh/./src/utils/condition.ts","webpack://probi-oh/./src/utils/free-card-processor.ts","webpack://probi-oh/./src/utils/game-state.ts","webpack://probi-oh/./src/utils/simulation.ts","webpack://probi-oh/./src/workers/simulation.worker.ts"],"sourcesContent":["function _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nexport { _arrayLikeToArray as default };","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;\n  }\n}\nexport { _unsupportedIterableToArray as default };","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nfunction _slicedToArray(r, e) {\n  return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();\n}\nexport { _slicedToArray as default };","function _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nexport { _arrayWithHoles as default };","function _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nexport { _iterableToArrayLimit as default };","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nexport { _nonIterableRest as default };","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nfunction _toConsumableArray(r) {\n  return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread();\n}\nexport { _toConsumableArray as default };","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return arrayLikeToArray(r);\n}\nexport { _arrayWithoutHoles as default };","function _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nexport { _iterableToArray as default };","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nexport { _nonIterableSpread as default };","function _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nexport { _classCallCheck as default };","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };","import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nexport { _createClass as default };","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nexport { _defineProperty as default };","function _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nexport { _getPrototypeOf as default };","function _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nexport { _setPrototypeOf as default };","/**\n * The type of cost that a free card must pay\n */\nexport enum CostType {\n    BanishFromDeck,\n    BanishFromHand,\n    PayLife,\n    Discard,\n}\n\n/**\n * The type of a condition that the free card imposes\n */\nexport enum ConditionType {\n    Discard,\n    BanishFromHand,\n    BanishFromDeck,\n}\n\n/**\n * The type of restriction that the free card imposes\n */\nexport enum RestrictionType {\n    NoSpecialSummon,\n    NoMoreDraws,\n    NoPreviousDraws,\n}\n\n/**\n * Represents the details of a free card in the game.\n */\nexport interface FreeCardDetails {\n    /**\n     * The number of free draws this card gives\n     */\n    count?: number;\n\n    /**\n     * If this card can only be used once per turn\n     */\n    oncePerTurn: boolean;\n\n    /**\n     * The cost that must be paid to use this card. If null then cost is not required\n     */\n    cost?: {\n        /**\n         * The type of cost that must be paid\n         */\n        type: CostType;\n\n        /**\n         * The value of the cost.\n         */\n        value: number | string[];\n    };\n\n    /**\n     * The condition that must be met to use this card. If null then no condition is imposed\n     */\n    condition?: {\n        /**\n         * The type of condition that is imposed\n         */\n        type: ConditionType;\n\n        /**\n         * The value of the condition.\n         */\n        value: number | string;\n    };\n\n    /**\n     * The restrictions that this card imposes. If null then no restrictions are imposed\n     */\n    restriction?: RestrictionType[];\n\n    /**\n     * The number of cards that must be excavated to use this card. If null then no excavation is required\n     */\n    excavate?: {\n        /**\n         * The number of cards that must be excavated\n         */\n        count: number;\n\n        /**\n         * The number of cards that must be picked from the excavated cards\n         */\n        pick: number;\n    }\n}\n\n/**\n * Represents the details of a card in the game.\n * @interface\n */\nexport interface CardDetails {\n    /**\n     * The quantity of the card in the deck.\n     */\n    qty?: number;\n    /**\n     * The tags associated with the card.\n     */\n    tags?: string[];\n    /**\n     * The details of a free card.\n     */\n    free?: FreeCardDetails;\n}\n","import _typeof from \"./typeof.js\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return assertThisInitialized(t);\n}\nexport { _possibleConstructorReturn as default };","function _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nexport { _assertThisInitialized as default };","import { CardDetails, ConditionType, CostType, RestrictionType } from \"./card-details\";\n\n/**\n * Represents a card in the game.\n * @class\n */\nclass Card {\n    private readonly _name: string;\n    private readonly _details: CardDetails;\n    private readonly _tags: readonly string[] | null;\n\n    /**\n     * Creates an instance of Card.\n     * @param {string} cardName - The name of the card.\n     * @param {CardDetails} cardDetails - The details of the card.\n     */\n    constructor(cardName: string, cardDetails: CardDetails) {\n        this._name = cardName;\n        this._details = cardDetails;\n        this._tags = cardDetails.tags || null;\n    }\n\n    /**\n     * Gets the name of the card.\n     * @returns {string} The card's name.\n     */\n    get name(): string {\n        return this._name;\n    }\n\n    /**\n     * Gets the lowercase name of the card.\n     * @returns {string} The card's name in lowercase.\n     */\n    get nameLower(): string {\n        return this.name.toLowerCase();\n    }\n\n    /**\n     * Gets the tags associated with the card.\n     * @returns {readonly string[] | null} An array of tags or null if no tags are present.\n     */\n    get tags(): readonly string[] | null {\n        return this._tags;\n    }\n\n    /**\n     * Gets the details of the card.\n     * @returns {Readonly<CardDetails>} The card's details.\n     */\n    get details(): Readonly<CardDetails> {\n        return this._details;\n    }\n\n    /**\n     * Checks if the card is free.\n     * @returns {boolean} True if the card is free, false otherwise.\n     */\n    get isFree(): boolean {\n        return false;\n    }\n}\n\nclass FreeCard extends Card\n{\n    constructor(cardName: string, cardDetails: CardDetails)\n    {\n        super(cardName, cardDetails);\n    }\n\n    get isFree(): boolean\n    {\n        return true;\n    }\n\n    get count(): number\n    {\n        return this.details.free!.count ? this.details.free!.count : 0;\n    }\n\n    get oncePerTurn(): boolean\n    {\n        return this.details.free!.oncePerTurn;\n    }\n\n    get restrictions(): RestrictionType[]\n    {\n        return this.details.free?.restriction || [];\n    }\n\n    get cost(): {type: CostType, value: number | string[]} | null\n    {\n        return this.details.free?.cost ?? null;\n    }\n\n    get condition(): {type: ConditionType, value: number | string} | null\n    {\n        return this.details.free?.condition ?? null;\n    }\n\n    get excavate(): {count: number, pick: number} | null\n    {\n        return this.details.free?.excavate ?? null;\n    }\n\n    get activationCount(): number\n    {\n        let count = this.count;\n\n        function costCount(cost: {type: CostType, value: number | string[]} | null): number {\n            if (typeof cost === \"undefined\" || cost === null) {\n                return 0;\n            }\n            if (typeof cost.value === \"number\") {\n                return cost.value;\n            }\n            if ( typeof cost.value === \"string\") {\n                return 1;\n            }\n\n            return 0;\n        }\n\n        switch (this.cost?.type) {\n            case CostType.BanishFromDeck:\n                count += costCount(this.cost);\n                break;\n\n            case CostType.BanishFromHand:\n            case CostType.Discard:\n            case CostType.PayLife:\n                break;\n        \n        }\n\n        return count;\n    }\n}\n\nexport function CreateCard(cardName: string, cardDetails: CardDetails): Card {\n    if (cardDetails.free) {\n        return new FreeCard(cardName, cardDetails);\n    }\n    return new Card(cardName, cardDetails);\n}\n\nexport type { Card, FreeCard };\n","import setPrototypeOf from \"./setPrototypeOf.js\";\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && setPrototypeOf(t, e);\n}\nexport { _inherits as default };","import { CardDetails } from \"./card-details\";\nimport { Card, CreateCard } from \"./card\";\n\n/** Represents a deck of cards */\nexport class Deck {\n    private _cards: Card[];\n\n    /**\n     * Creates a new Deck\n     * @param cards - Initial array of Cards\n     * @param deckSize - Size of the deck (default 40)\n     */\n    constructor(cards: Card[], deckSize: number = 40) {\n        const missingCount = deckSize - cards.length;\n        if (missingCount > 0) {\n            cards.push(...Array(missingCount).fill(CreateCard(\"Empty Card\", {tags: [\"Empty\", \"Blank\", \"Non Engine\"]})));\n        }\n        this._cards = cards.slice();\n        this.shuffle();\n    }\n\n    /** Creates a deep copy of the deck */\n    deepCopy(): Deck {\n        const newDeck = new Deck([], this._cards.length);\n        newDeck._cards = this._cards.map(card => CreateCard(card.name, { ...card.details }));\n        return newDeck;\n    }\n\n    /** Draws a card from the top of the deck */\n    drawCard(): Card {\n        if (this._cards.length === 0) {\n            throw new Error(\"Cannot draw from an empty deck\");\n        }\n        \n        return this._cards.pop()!;\n    }\n\n    /** Shuffles the deck */\n    shuffle(randomFn: () => number = Math.random): void {\n        for (let i = this._cards.length - 1; i > 0; i--) {\n            const j = Math.floor(randomFn() * (i + 1));\n            [this._cards[i], this._cards[j]] = [this._cards[j], this._cards[i]];\n        }\n    }\n\n    public addToBottom(cards: Card[]): void {\n        this._cards.push(...cards);\n    }\n\n    /** Gets the list of cards in the deck (copy of array) */\n    get deckList(): Card[] {\n        return [...this._cards];\n    }\n\n    /** Gets the number of cards in the deck */\n    get deckCount(): number {\n        return this._cards.length;\n    }\n}\n\n/**\n * Builds a deck from a record of card details\n * @param deckList - Record of card names and their details\n * @returns A new Deck instance\n */\nexport function buildDeck(deckList: Map<string, CardDetails>): Deck {\n    const cards: Card[] = [];\n    for (const [card, details] of deckList) {\n        const qty = details.qty ?? 1;\n        cards.push(...Array(qty).fill(CreateCard(card, details)));\n    }\n    return new Deck(cards);\n}","import { AndCondition, BaseCondition, Condition, LocationConditionTarget, OrCondition } from \"./condition\";\n\n/** Represents a token in the parsed input */\ninterface Token {\n    type: string;\n    value: string;\n}\n\n/**\n * Parses an array of tokens into a BaseCondition\n * @param tokens - Array of tokens to parse\n * @returns A BaseCondition representing the parsed expression\n */\nfunction parse(tokens: Token[]): BaseCondition {\n    let current = 0;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    let parenCount = 0;\n\n    /** Walks through tokens and constructs conditions */\n    function walk(): BaseCondition {\n\n        function GetLocationToken(token: {type: string, value: string} | undefined): LocationConditionTarget {\n            // If this token is not location then the default location is hand\n            if (!token || token?.type !== 'location') {\n                return LocationConditionTarget.Hand;\n            }\n\n            current++;\n\n            // parse the token and return the type\n            switch (token.value.toLowerCase()) {\n                case 'deck':\n                    return LocationConditionTarget.Deck;\n                case 'hand':\n                    return LocationConditionTarget.Hand;\n                default:\n                    throw new TypeError('Invalid location: ' + token.value);\n            }\n        }\n\n        const token = tokens[current];\n        if (token.type === 'number') {\n            current++;\n            const nextToken = tokens[current];\n            if (nextToken) {\n                if (nextToken.type === 'name') {\n                    current++;\n                    const quantity = parseInt(token.value);\n                    // Determine the operator based on the presence of + or -\n                    const operator = token.value.includes('+') ? '>=' : token.value.includes('-') ? '<=' : '=';\n\n                    // Check for location token\n                    const location = GetLocationToken(tokens[current]);\n\n                    return new Condition(nextToken.value, quantity, operator, location);\n                } else {\n                    throw new TypeError('Expected card name after number');\n                }\n            }\n        }\n\n        if (token.type === 'name') {\n            current++;\n            \n            // Check for location token\n            const location = GetLocationToken(tokens[current]);\n\n            return new Condition(token.value, 1, '>=', location);\n        }\n\n        if (token.type === 'paren') {\n            if (token.value === '(') {\n                parenCount++;\n                current++;\n                const result = parseExpression();\n                // Ensure matching closing parenthesis\n                if (tokens[current].type !== 'paren' || tokens[current].value !== ')') {\n                    throw new SyntaxError('Expected closing parenthesis');\n                }\n                parenCount--;\n                current++;\n                return result;\n            } else {\n                throw new SyntaxError('Unexpected closing parenthesis');\n            }\n        }\n\n        throw new TypeError(`Unexpected token type: ${token.type}`);\n    }\n\n    /** Parses expressions, handling AND and OR operations */\n    function parseExpression(): BaseCondition {\n        const lastToken = tokens[current - 1];\n        const hasParentheses = (lastToken?.type === 'paren' && lastToken.value === '(');\n\n        let left: BaseCondition = walk();\n    \n        while (current < tokens.length && tokens[current].type === 'operator') {\n            const operator = tokens[current].value;\n            current++;\n            const right: BaseCondition = walk();\n            // Create AndCondition or OrCondition based on the operator\n            left = operator === 'AND' ? new AndCondition([left, right], hasParentheses) : new OrCondition([left, right], hasParentheses);\n        }\n    \n        return left;\n    }\n\n    const result = parseExpression();\n    \n    // Check for any unexpected tokens after parsing\n    if (current < tokens.length) {\n        if (tokens[current].type === 'paren' && tokens[current].value === ')') {\n            throw new SyntaxError('Unexpected closing parenthesis');\n        } else {\n            throw new SyntaxError('Unexpected token after valid expression');\n        }\n    }\n\n    return result;\n}\n\n/**\n * Tokenizes an input string into an array of tokens\n * @param input - The string to tokenize\n * @returns An array of Token objects\n */\nfunction tokenize(input: string): Token[] {\n    const tokens: Token[] = [];\n    let current = 0;\n\n    function isLocationToken(slice: string): RegExpMatchArray | null {\n        return slice.match(/^IN /);\n    }\n\n    function tokenizeQuantity(): boolean {\n        // Handle numbers (including + and - for operators)\n        const NUMBERS = /[0-9]/;\n        const validNumber = /[0-9](\\+||-)? /;\n        let char = input[current];\n        if (validNumber.test(input.slice(current, current + 3))) {\n            let value = '';\n            while (NUMBERS.test(char)) {\n                value += char;\n                char = input[++current];\n            }\n            if (char === '+' || char === '-') {\n                value += char;\n                char = input[++current];\n            }\n\n            tokens.push({ type: 'number', value });\n            return true;\n        }\n\n        return false;\n    }\n\n    function tokenizeName(): boolean {\n        const NAME_CHARS = /[a-zA-Z0-9\\s\\-',.&:!?\"]+$/;\n        let char = input[current];\n\n        function isCharIllegal(char: string): boolean {\n            const ILLEGAL_CHARS = new RegExp(`[^${NAME_CHARS.source.slice(1, -1)}]`);\n            if (ILLEGAL_CHARS.test(char)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        if (NAME_CHARS.test(char)) {\n            let value = '';\n            while (current < input.length && (NAME_CHARS.test(char) || char === ' ')) {\n                if (isCharIllegal(char)) {\n                    throw new TypeError('Illegal character in card name: ' + char);\n                }\n\n                if (char !== ' ' || (value && NAME_CHARS.test(input[current + 1]))) {\n                    value += char;\n                }\n                char = input[++current];\n\n                // Break if we encounter an AND or OR operator\n                if (isANDToken(input.slice(current)) || isORToken(input.slice(current)) || isLocationToken(input.slice(current))) {\n                    break;\n                }\n            }\n            tokens.push({ type: 'name', value: value.trim() });\n            return true;\n        }\n\n        return false;\n    }\n\n    function tokenizeLocation(slice: string): boolean {\n        // Check if this is a valid location token\n        if (isLocationToken(slice)) {\n            // it is so pull the location\n            current += 3;\n            const LOCATION_PATTERN = /(deck|hand)/i;\n            const location = input.slice(current).match(LOCATION_PATTERN)![0];\n            \n            if (!location) {\n                throw new TypeError('Expected location after \"IN\"');\n            }\n\n            // push the location token\n            tokens.push({ type: 'location', value: location });\n            current += location.length;\n            return true;\n        }\n\n        // no location token found\n        return false;\n    }\n\n    function isANDToken(slice: string): RegExpMatchArray | null {\n        return slice.match(/^AND\\b/);\n    }\n\n    function isORToken(slice: string): RegExpMatchArray | null {\n        return slice.match(/^OR\\b/);\n    }\n\n    while (current < input.length) {\n        const char = input[current];\n\n        // Handle parentheses\n        if (char === '(' || char === ')') {\n            tokens.push({ type: 'paren', value: char });\n            current++;\n            continue;\n        }\n\n        // Skip whitespace\n        const WHITESPACE = /\\s/;\n        if (WHITESPACE.test(char)) {\n            current++;\n            continue;\n        }\n\n        // Check for AND operator\n        if (isANDToken(input.slice(current))) {\n            tokens.push({ type: 'operator', value: 'AND' });\n            current += 3;\n            continue;\n        }\n\n        // Check for OR operator\n        if (isORToken(input.slice(current))) {\n            tokens.push({ type: 'operator', value: 'OR' });\n            current += 2;\n            continue;\n        }\n\n        // if the last token was a number the next token must be a name\n        const last_token = tokens[tokens.length - 1];\n        if (last_token?.type === 'number') {\n            if (tokenizeName()) {\n                continue;\n            }\n        }\n\n        if (tokenizeQuantity()) {\n            continue;\n        }\n\n        if (tokenizeLocation(input.slice(current))) {\n            continue;\n        }\n\n        if (tokenizeName()) {\n            continue;\n        }\n\n        throw new TypeError(`Unknown character: ${char} at position ${current} of ${input}`);\n    }\n\n    return tokens;\n}\n\n/**\n * Parses a condition string into a BaseCondition\n * @param conditions - The condition string to parse\n * @returns A BaseCondition representing the parsed condition\n */\nexport function parseCondition(conditions: string): BaseCondition {\n    const tokens = tokenize(conditions);\n    return parse(tokens);\n}","import { Card } from './card';\nimport { Deck } from './deck';\nimport { GameState } from './game-state';\nimport { parseCondition } from './parser';\n\nexport interface SerialisedCondition {\n    condition: string;\n    successes: number;\n    failures: number;\n}\n\n/** Base condition interface for card evaluation */\nexport interface BaseCondition {\n    /** The cards in the hand required for this condition */\n    requiredCards(hand: Card[]): Card[];\n\n    toString(): string;\n\n    recordSuccess(): void;\n\n    recordFailure(): void;\n\n    /** Number of successful evaluations */\n    get successes(): number;\n\n    /** Number of successful evaluations */\n    get failures(): number;\n\n    /** Total number of evaluations */\n    get totalEvaluations(): number;\n}\n\nexport enum LocationConditionTarget {\n    Hand,\n    Deck\n}\n\nexport function serialiseCondition(condition: BaseCondition): SerialisedCondition {\n    return {\n        condition: condition.toString(),\n        successes: condition.successes,\n        failures: condition.failures\n    };\n}\n\nexport function deserialiseCondition(serialisedCondition: SerialisedCondition): BaseCondition {\n    const condition = parseCondition(serialisedCondition.condition);\n    for (let i = 0; i < serialisedCondition.successes; i++) {\n        condition.recordSuccess();\n    }\n    for (let i = 0; i < serialisedCondition.failures; i++) {\n        condition.recordFailure();\n    }\n\n    return condition;\n}\n\nfunction getMatchingCards(condition: Condition, cardList: Card[]): Card[] {\n    return cardList.filter(card => \n        card.name === condition.cardName || (card.tags && card.tags.includes(condition.cardName))\n    );\n}\n\n/** Specific condition for card evaluation */\nexport class Condition implements BaseCondition {\n    private _successes: number = 0;\n    private _failures: number = 0;\n\n    /**\n     * Creates a new Condition\n     * @param cardName - Name of the card to evaluate\n     * @param quantity - Quantity to compare against\n     * @param operator - Comparison operator\n     */\n    constructor(\n        readonly cardName: string, \n        readonly quantity: number = 1, \n        readonly operator: string = '>=',\n        readonly location: LocationConditionTarget = LocationConditionTarget.Hand\n    ) {\n    }\n\n    /** Number of successful evaluations */\n    get successes(): Readonly<number> {\n        return this._successes;\n    }\n\n    recordSuccess(): void {\n        this._successes++;\n    }\n\n    get failures(): Readonly<number> {\n        return this._failures;\n    }\n\n    recordFailure(): void {\n        this._failures++;\n    }\n\n    get totalEvaluations(): Readonly<number> {\n        return this.successes + this.failures;\n    }\n\n    requiredCards(hand: Card[]): Card[] {\n        const _hand = hand.slice();\n        const _requiredCards = [];\n        // Remove cards used for this condition\n        for (let i = 0; i < this.quantity; i++) {\n            const index = _hand.findIndex(card => card.name === this.cardName || (card.tags && card.tags.includes(this.cardName)));\n            if (index === -1) {\n                return [];\n            }\n\n            _requiredCards.push(_hand[index]);\n            _hand.splice(index, 1);\n        }\n\n        return _requiredCards;\n    }\n\n    toString(): string {\n        function operatorToSign(operator: string): string {\n            switch (operator) {\n                case '>=': return '+';\n                case '=': return '';\n                case '<=': return '-';\n                default: return operator;\n            }\n        }\n        return `${this.quantity}${operatorToSign(this.operator)} ${this.cardName} IN ${LocationConditionTarget[this.location]}`;\n    }\n}\n\n/** Logical AND condition composed of multiple base conditions */\nexport class AndCondition implements BaseCondition {\n    private _successes: number = 0;\n    private _failures: number = 0;\n\n    constructor(\n        readonly conditions: BaseCondition[],\n        readonly hasParentheses: boolean = true\n    ) {\n        if (conditions.some(condition => condition == undefined)) {\n            console.error(`Found a dead condition`);\n        }\n    }\n\n    get successes(): Readonly<number> {\n        return this._successes;\n    }\n\n    recordSuccess(): void {\n        this._successes++;\n    }\n\n    get failures(): Readonly<number> {\n        return this._failures;\n    }\n\n    recordFailure(): void {\n        this._failures++;\n    }\n\n    get totalEvaluations(): Readonly<number> {\n        return this.successes + this.failures;\n    }\n\n    private checkCombinations(hand: Card[], deck: Deck, conditions: BaseCondition[]): boolean {\n        if (conditions.length === 0) {\n            return true; // All conditions have been satisfied\n        }\n\n        const currentCondition = conditions[0];\n        const remainingConditions = conditions.slice(1);\n\n        // Get all possible combinations of cards that satisfy the current condition\n        const possibleCombinations = this.getPossibleCombinations(hand, deck, currentCondition);\n\n        for (const usedCards of possibleCombinations) {\n            const remainingHand = hand.filter(card => !usedCards.includes(card));\n            \n            // Recursively check if the remaining conditions can be satisfied with the remaining hand\n            if (this.checkCombinations(remainingHand, deck, remainingConditions)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private getPossibleCombinations(hand: Card[], deck: Deck, condition: BaseCondition): Card[][] {\n        if (condition instanceof Condition) {\n            const matchingCards = hand.filter(card => \n                card.name === condition.cardName || (card.tags && card.tags.includes(condition.cardName))\n            );\n\n            // Generate all combinations of the required number of cards\n            return this.getCombinations(matchingCards, condition.quantity);\n        } else {\n            // For nested conditions, we need to evaluate them separately\n            const tempGameState = {\n                get hand() {\n                    return hand;\n                },\n                get deck() {\n                    return deck;\n                }\n            } as GameState;\n    \n\n            if (evaluateCondition(condition, tempGameState.hand, tempGameState.deck.deckList)) {\n                return [condition.requiredCards(hand)];\n            }\n            return [];\n        }\n    }\n\n    private getCombinations(cards: Card[], k: number): Card[][] {\n        if (k > cards.length || k <= 0) {\n            return [];\n        }\n        if (k === cards.length) {\n            return [cards];\n        }\n        if (k === 1) {\n            return cards.map(card => [card]);\n        }\n\n        const combinations: Card[][] = [];\n        for (let i = 0; i < cards.length - k + 1; i++) {\n            const head = cards[i];\n            const tailCombos = this.getCombinations(cards.slice(i + 1), k - 1);\n            tailCombos.forEach(tailCombo => {\n                combinations.push([head, ...tailCombo]);\n            });\n        }\n        return combinations;\n    }\n\n    requiredCards(hand: Card[]): Card[] {\n        const usedCards: Set<Card> = new Set();\n        this.checkCombinations(hand, new Deck([]), this.conditions);\n        return Array.from(usedCards);\n    }\n\n    toString(): string {\n        return `${this.hasParentheses ? '(' : ''}${this.conditions.map(c => c.toString()).join(' AND ')}${this.hasParentheses ? ')' : ''}`;\n    }\n}\n\n/** Logical OR condition composed of multiple base conditions */\nexport class OrCondition implements BaseCondition {\n    private _successes: number = 0;\n    private _failures: number = 0;\n\n    /**\n     * Creates a new OrCondition\n     * @param conditions - Array of BaseCondition objects\n     */\n    constructor(readonly conditions: BaseCondition[],\n                readonly hasParentheses: boolean = true) {\n        if (conditions.some(condition => condition == undefined)) {\n            console.error(`Found a dead condition`);\n        }\n    }\n\n    /** Number of successful evaluations */\n    get successes(): Readonly<number> {\n        return this._successes;\n    }\n\n    recordSuccess(): void {\n        this._successes++;\n    }\n\n    get failures(): Readonly<number> {\n        return this._failures;\n    }\n\n    recordFailure(): void {\n        this._failures++;\n    }\n\n    get totalEvaluations(): Readonly<number> {\n        return this.successes + this.failures;\n    }\n\n    requiredCards(hand: Card[]): Card[] {\n        let _hand = hand.slice();\n\n        return this.conditions.flatMap(condition => {\n            const cardsUsed = condition.requiredCards(_hand);\n            _hand = _hand.filter(card => !cardsUsed.includes(card));\n            return cardsUsed;\n        });\n    }\n\n    toString(): string {\n        return `${this.hasParentheses ? '(' : ''}${this.conditions.map(c => c.toString()).join(' OR ')}${this.hasParentheses ? ')' : ''}`;\n    }\n}\n\nfunction generateHandPermutations(hand: Card[]): Card[][] {\n    function permute(arr: Card[], start: number = 0): Card[][] {\n        if (start === arr.length - 1) {\n            return [arr.slice()];\n        }\n\n        const permutations: Card[][] = [];\n\n        for (let i = start; i < arr.length; i++) {\n            [arr[start], arr[i]] = [arr[i], arr[start]]; // Swap elements\n            permutations.push(...permute(arr, start + 1));\n            [arr[start], arr[i]] = [arr[i], arr[start]]; // Swap back\n        }\n\n        return permutations;\n    }\n\n    return permute(hand);\n}\n\ninterface Result {\n    success: boolean;\n    usedCards: Card[];\n}\n\nfunction evaluateSimpleCondition(condition: Condition, \n                                 hand: Card[], \n                                 deck: Card[]): Result {\n    /** Evaluates the condition against a hand of cards */\n    function evaluate(): Result {\n        let cardList: Card[] = [];\n        switch (condition.location) {\n            case LocationConditionTarget.Deck:\n                cardList = deck\n                break;\n            default:\n                console.error(`Unknown location: ${condition.location}`);\n                // Fallthrough to Hand case\n            case LocationConditionTarget.Hand:\n                cardList = hand;\n                break;\n        }\n\n        const count = getMatchingCards(condition, cardList).length;\n\n        let result = false;\n        let usedCards: Card[] = [];\n        switch(condition.operator) {\n            case '>=': \n                result = count >= condition.quantity;\n                usedCards = getMatchingCards(condition, cardList).slice(0, condition.quantity);\n                break;\n\n            case '=': \n                result = count === condition.quantity; \n                usedCards = getMatchingCards(condition, cardList).slice(0, condition.quantity);\n                break;\n\n            case '<=': \n                result = count <= condition.quantity; \n                break;\n\n            default: throw new Error(`Unknown operator: ${condition.operator}`);\n        }\n\n        if (result) {\n            condition.recordSuccess();\n        } else {\n            condition.recordFailure();\n        }\n\n        return {\n            success: result,\n            usedCards: usedCards\n        };\n    }\n\n    return evaluate();\n}\n\nfunction evaluateAndCondition(condition: AndCondition, hand: Card[], deck: Card[]): Result {\n    function evaluate(): Result {\n        // init as a pass\n        const result: Result = { success: true, usedCards: [] };\n        condition.conditions.forEach(condition => {\n            const ret = checkCondition(condition, hand.filter(c => !result.usedCards.includes(c)), deck)\n            if (!ret.success) {\n                // then if any result fails consider the overall failure (.every)\n                result.success = false;\n            } else {\n                result.usedCards.push(...ret.usedCards);\n            }\n        });\n        \n        if (result.success) {\n            condition.recordSuccess();\n        } else {\n            condition.recordFailure();\n        }\n\n        return result;\n    }\n\n    return evaluate();\n}\n\nfunction evaluateOrCondition(condition: OrCondition, hand: Card[], deck: Card[]): Result {\n    function evaluate(): Result {\n        // init as a fail\n        const result: Result = { success: false, usedCards: [] };\n        condition.conditions.forEach(condition => {\n            if (checkCondition(condition, hand, deck).success) {\n                // then if any result passes consider the overall failure (.some)\n                result.success = true;\n            }\n        });\n        \n        if (result.success) {\n            condition.recordSuccess();\n        } else {\n            condition.recordFailure();\n        }\n\n        return result;\n    }\n\n    return evaluate();\n}\n\nfunction checkCondition(condition: BaseCondition, hand: Card[], deck: Card[]): Result {\n    let result;\n    \n    if (condition instanceof Condition) {\n        result = evaluateSimpleCondition(condition, hand, deck);\n    } else if (condition instanceof AndCondition) {\n        result = evaluateAndCondition(condition, hand, deck);\n    } else if (condition instanceof OrCondition) {\n        result = evaluateOrCondition(condition, hand, deck);\n    } else {\n        throw new Error(`Unknown condition type: ${condition}`);\n    }\n\n    return result;\n}\n\nexport function evaluateCondition(condition: BaseCondition, hand: Card[], deck: Card[]): boolean {\n    const permutations = generateHandPermutations(hand);\n\n    for (const hand of permutations) {\n        if (checkCondition(condition, hand, deck).success) {\n            return true;\n        }\n    }\n\n    return false;\n}","import { Card, FreeCard } from \"./card\";\nimport { ConditionType, CostType, RestrictionType } from \"./card-details\";\nimport { SimulationBranch } from \"./simulation\";\nimport { GameState } from './game-state';\nimport { AndCondition, BaseCondition, Condition, evaluateCondition, OrCondition } from \"./condition\";\n\nfunction cardCanPayCost(gameState: GameState, card: FreeCard): boolean {\n    if (!card.cost) {\n        return true;\n    }\n\n    const handLessCard = gameState.hand.filter(handCard => handCard !== card);\n\n    switch (card.cost.type)\n    {\n        case CostType.BanishFromDeck:\n            if (typeof(card.cost.value) === \"number\") {\n                if (gameState.deck.deckCount < (card.cost.value as number)) {\n                    return false;\n                }\n            } else if (typeof(card.cost.value) === \"string\") {\n                return false;\n            }\n            \n            break;\n\n        case CostType.BanishFromHand:\n            if (handLessCard.length < (card.cost.value as number))\n            {\n                return false;\n            }\n            break;\n\n        case CostType.Discard:\n            if (typeof(card.cost.value) === \"number\") {\n                if (handLessCard.length < (card.cost.value as number)) {\n                    return false;\n                }\n            }\n            break;\n\n        case CostType.PayLife:\n            // We don't care about life points\n            break;\n    }\n\n    return true;\n}\n\nfunction checkCardRestrictions(gameState: GameState, card: FreeCard): boolean {\n    if (card.restrictions)\n    {\n        for (const restriction of card.restrictions)\n        {\n            switch (restriction)\n            {\n                case RestrictionType.NoSpecialSummon:\n                    // We don't care... yet\n                    break;\n\n                case RestrictionType.NoMoreDraws:\n                    // gameState is not something we care about\n                    break;\n\n                case RestrictionType.NoPreviousDraws:\n                    // If we have already used any free cards, then we can't use gameState card\n                    if (gameState.freeCardsPlayedThisTurn.length > 0)\n                    {\n                        return false;\n                    }\n                    break;\n            }\n        }\n    }\n\n    return true;\n}\n\nexport function freeCardIsUsable(gameState: GameState, card: FreeCard): boolean {\n    // Check if the card is once per turn and has already been used \n    if (card.oncePerTurn && gameState.cardsPlayedThisTurn.some(usedCard => usedCard.name === card.name))\n    {\n        return false;\n    }\n\n    // Check there are enough cards in the deck to draw\n    if (gameState.deck.deckCount < card.activationCount)\n    {\n        return false;\n    }\n\n    // Check if any cards already impose the no more cards restriction\n    if (gameState.freeCardsPlayedThisTurn.some(usedCard => usedCard.restrictions?.includes(RestrictionType.NoMoreDraws)))\n    {\n        return false;\n    }\n\n    // If the card has restrictions\n    if (!checkCardRestrictions(gameState, card)) {\n        return false;\n    }\n\n    // Check we can pay cost if required\n    if (!cardCanPayCost(gameState, card))\n    {\n        return false;\n    }\n\n    return true;\n}\n\nfunction payCost(gameState: GameState, card: FreeCard, condition: BaseCondition): void {\n    if (!card.cost) {\n        return;\n    }\n\n    const requiredCards = condition.requiredCards(gameState.hand);\n\n    switch (card.cost.type) {\n        case CostType.BanishFromDeck:\n            gameState.banishFromHand([...Array(card.cost.value as number)].map(() => gameState.deck.drawCard()));\n            break;\n\n        case CostType.BanishFromHand:\n        case CostType.Discard:\n        {\n            const availableCards = gameState.hand.filter(c => !requiredCards.includes(c));\n            let cardsToRemove = [];\n\n            if (typeof(card.cost.value) === \"number\") {\n                cardsToRemove.push(...availableCards.slice(0, card.cost.value as number));\n                \n                if (cardsToRemove.length < (card.cost.value as number)) {\n                    throw new Error(\"Not enough cards to pay cost\");\n                }\n            } else {\n                const requirements = card.cost.value as string[];\n                cardsToRemove = availableCards.filter(c => requirements.includes(c.name) || c.tags?.some(t => requirements.includes(t)));\n\n                if (!cardsToRemove) {\n                    throw new Error(\"No card to pay cost\");\n                }\n            }\n\n            if (card.cost.type === CostType.BanishFromHand) {\n                gameState.banishFromHand(cardsToRemove);\n            } else {\n                gameState.discardFromHand(cardsToRemove);\n            }\n        }\n            break;\n\n        case CostType.PayLife:\n            // We don't care about life points\n            break;\n    }\n}\n\nexport function excavate(gameState: GameState, card: FreeCard, condition: BaseCondition): void {\n    if (!card.excavate) {\n        return;\n    }\n\n    const { count, pick } = card.excavate;\n    const excavatedCards = [...Array(count)].map(() => gameState.deck.drawCard());\n    \n    // Calculate the base score (how many conditions are met with the current hand)\n    const baseScore = countMetConditions(condition, gameState, null);\n\n    // Sort excavated cards based on their contribution to completing the condition\n    const sortedCards = excavatedCards.sort((a, b) => {\n        const aScore = countMetConditions(condition, gameState, a) - baseScore;\n        const bScore = countMetConditions(condition, gameState, b) - baseScore;\n        return bScore - aScore; // Sort in descending order\n    });\n\n    // Add the best cards to the hand\n    gameState.hand.push(...sortedCards.slice(0, pick));\n\n    // Put the rest back on top of the deck\n    gameState.deck.addToBottom(sortedCards.slice(pick));\n}\n\nfunction countMetConditions(condition: BaseCondition, gameState: GameState, card: Card | null): number {\n    const localGameState = gameState.deepCopy();\n\n    if (condition instanceof Condition) {\n        if (card) {\n            const hand = localGameState.hand;\n            hand.push(card);\n        }\n\n        return evaluateCondition(condition, gameState.hand, gameState.deck.deckList) ? 1 : 0;\n    } else if (condition instanceof AndCondition) {\n        return condition.conditions.filter(c => countMetConditions(c, localGameState, card) > 0).length;\n    } else if (condition instanceof OrCondition) {\n        return condition.conditions.some(c => countMetConditions(c, localGameState, card) > 0) ? 1 : 0;\n    }\n    return 0;\n}\n\nfunction payPostConditions(gameState: GameState, card: FreeCard, condition: BaseCondition): boolean {\n    if (!card.condition) {\n        return true;\n    }\n\n    const requiredCards = condition.requiredCards(gameState.hand);\n\n    switch (card.condition.type) {\n        case ConditionType.BanishFromDeck:\n            gameState.banishFromHand([...Array(card.condition.value as number)].map(() => gameState.deck.drawCard()));\n            break;\n\n        case ConditionType.Discard:\n        case ConditionType.BanishFromHand:\n        {\n            const availableCards = gameState.hand.filter(c => !requiredCards.includes(c));\n\n            if (typeof(card.condition.value) === \"number\") {\n                const count = card.condition.value as number;\n                if (availableCards.length < count) {\n                    return false;\n                }\n\n                const cardsToRemove = availableCards.slice(0, count);\n\n                if (card.condition.type === ConditionType.BanishFromHand) {\n                    gameState.banishFromHand(cardsToRemove);\n                } else {\n                    gameState.discardFromHand(cardsToRemove);\n                }\n    \n                let hand = gameState.hand;\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                hand = gameState.hand.filter(c => !cardsToRemove.includes(c));\n            } else {\n                const requirement = card.condition.value as string;\n                \n                const cardToRemove = availableCards.find(c => c.tags?.includes(requirement) || c.name === requirement);\n\n                if (!cardToRemove) {\n                    return false;\n                }\n\n                if (card.condition.type === ConditionType.BanishFromHand) {\n                    gameState.banishFromHand([cardToRemove]);\n                } else {\n                    gameState.discardFromHand([cardToRemove]);\n                }\n    \n                let hand = gameState.hand;\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                hand = gameState.hand.filter(c => c === cardToRemove);\n                break;\n            }\n        }\n            break;\n    }\n\n    return true;\n}\n\nfunction handleFreeCard(gameState: GameState, card: FreeCard, condition: BaseCondition): void {\n    if (!gameState.hand.includes(card)) {\n        console.error(\"Card is not in the player's hand\");\n        return;\n    }\n\n    if (!freeCardIsUsable(gameState, card)) {\n        return;\n    }\n\n    gameState.playCard(card);\n\n    // pay cost\n    payCost(gameState, card, condition);\n\n    // draw cards\n    if (card.count > 0) {\n        gameState.hand.push(...[...Array(card.count)].map(() => gameState.deck.drawCard()));\n    }\n\n    // excavate\n    excavate(gameState, card, condition);\n\n    if (!payPostConditions(gameState, card, condition)) {\n        // we failed the post condition. This should be considered a total failure, how? idk\n        // for the moment discard hand so we kill conditions\n        gameState.discardFromHand(gameState.hand);\n        return;\n    }\n}\n\nexport function processFreeCard(simulation: SimulationBranch, freeCard: FreeCard): void {\n    if (!simulation.gameState.hand.find(c => c.name === freeCard.name)) {\n        console.error(\"Card is not in the player's hand\");\n        return;\n    }\n\n    const cardInHand = simulation.gameState.hand.find(c => c.name === freeCard.name) as FreeCard;\n\n    if (!freeCardIsUsable(simulation.gameState, cardInHand)) {\n        return;\n    }\n\n    handleFreeCard(simulation.gameState, cardInHand, simulation.condition);\n}","import { Card, CreateCard, FreeCard } from \"./card\";\nimport { CardDetails } from \"./card-details\";\nimport { buildDeck, Deck } from \"./deck\";\n\n\nexport interface SerialisedGameState {\n    hand: { name: string; details: CardDetails }[];\n    deck: { name: string; details: CardDetails }[];\n    banishPile: { name: string; details: CardDetails }[];\n    graveyard: { name: string; details: CardDetails }[];\n    cardsPlayedThisTurn: { name: string; details: CardDetails }[];\n}\n\n/** Represents the current state of a game */\nexport class GameState {\n    private _deck: Deck;\n    private _hand: Card[] = [];\n    private _banishPile: Card[] = [];\n    private _graveyard: Card[] = [];\n    private _cardsPlayed: Card[] = [];\n\n    /**\n     * Creates a new GameState\n     * @param deck - The deck to use for this game\n     * @param handSize - The number of cards to draw for the initial hand\n     */\n    constructor(deck: Deck) {\n        this._deck = deck.deepCopy();\n        this._deck.shuffle();\n    }\n\n    /** Creates a deep copy of the game state */\n    public deepCopy(): GameState {\n        const newState = new GameState(this._deck);\n        this._deck = this._deck.deepCopy(); // need to recopy the deck since the constructor will draw a hand\n        newState._hand = this._hand.map(card => CreateCard(card.name, { ...card.details }));\n        newState._banishPile = this._banishPile.map(card => CreateCard(card.name, { ...card.details }));\n        newState._graveyard = this._graveyard.map(card => CreateCard(card.name, { ...card.details }));\n        return newState;\n    }\n\n    public serialise(): SerialisedGameState {\n        return {\n            hand: this.hand.map(card => ({ name: card.name, details: card.details })),\n            deck: this.deck.deckList.map(card => ({ name: card.name, details: card.details })),\n            banishPile: this.banishPile.map(card => ({ name: card.name, details: card.details })),\n            graveyard: this.graveyard.map(card => ({ name: card.name, details: card.details })),\n            cardsPlayedThisTurn: this.cardsPlayedThisTurn.map(card => ({ name: card.name, details: card.details }))\n        };\n    }\n\n    public static deserialize(serialisedGameState: SerialisedGameState): GameState {\n        const deck = buildDeck(new Map(serialisedGameState.deck.map(c => [c.name, c.details])));\n        const gameState = new GameState(deck);\n        gameState._hand = serialisedGameState.hand.map(c => CreateCard(c.name, c.details));\n        gameState._banishPile = serialisedGameState.banishPile.map(c => CreateCard(c.name, c.details));\n        gameState._graveyard = serialisedGameState.graveyard.map(c => CreateCard(c.name, c.details));\n        gameState._cardsPlayed = serialisedGameState.cardsPlayedThisTurn.map(c => CreateCard(c.name, c.details));\n        return gameState;\n    }\n\n    public drawHand(handSize: number = 5): void {\n        this._hand = Array(handSize).fill(null).map(() => this._deck.drawCard());\n    }\n\n    public playCard(card: Card): void {\n        if (!this._hand.includes(card)) {\n            console.error(\"Card is not in the player's hand\");\n            return;\n        }\n\n        if (card.isFree) {\n            const freeCard = card as FreeCard;\n            \n            if (freeCard.oncePerTurn && this.cardsPlayedThisTurn.some(usedCard => usedCard.name === card.name)) {\n                console.error(\"Card has already been played this turn and is only usable once per turn\");\n            }\n        }\n\n        this._cardsPlayed.push(card);\n        this._hand = this._hand.filter(handCard => handCard !== card);\n    }\n\n    public discardFromHand(cards: Card[]) {\n        this._graveyard.push(...cards);\n        this._hand = this._hand.filter(card => !cards.includes(card));\n    }\n\n    public banishFromHand(cards: Card[]) {\n        this._banishPile.push(...cards);\n        this._hand = this._hand.filter(card => !cards.includes(card));\n    }\n\n    /** Gets the current deck */\n    get deck(): Deck {\n        return this._deck;\n    }\n\n    /** Gets the current hand */\n    get hand(): Card[] {\n        return this._hand;\n    }\n\n    /** Gets the banish pile */\n    get banishPile(): Readonly<Card[]> {\n        return this._banishPile;\n    }\n\n    /** Gets the graveyard */\n    get graveyard(): Readonly<Card[]> {\n        return this._graveyard;\n    }\n\n    /** Gets the free cards in hand */\n    get freeCardsInHand(): FreeCard[] {\n        return this._hand.filter(card => card.isFree) as FreeCard[];\n    }\n\n    /** Gets the cards played this turn */\n    get cardsPlayedThisTurn(): Card[] {\n        return this._cardsPlayed;\n    }\n\n    get freeCardsPlayedThisTurn(): FreeCard[] {\n        return this.cardsPlayedThisTurn.filter(card => card.isFree) as FreeCard[];\n    }\n}\n","import { FreeCard } from \"./card\";\nimport { BaseCondition, deserialiseCondition, evaluateCondition, serialiseCondition, SerialisedCondition } from \"./condition\";\nimport { freeCardIsUsable, processFreeCard } from \"./free-card-processor\";\nimport { GameState, SerialisedGameState } from \"./game-state\";\n\nexport interface SerialisedSimulation {\n    gameState: SerialisedGameState;\n    conditions: SerialisedCondition[];\n    branches: SerialisedSimulationBranch[];\n}\n\ninterface SerialisedSimulationBranch {\n    result: boolean;\n    gameState: SerialisedGameState;\n    condition: SerialisedCondition;\n}\n\nexport class SimulationBranch {\n    private readonly _gameState: GameState;\n    private _result: boolean;\n    private _condition: BaseCondition;\n\n    constructor(gameState: GameState, condition: BaseCondition) {\n        this._gameState = gameState.deepCopy();\n        this._result = false;\n        this._condition = condition;\n    }\n\n    run(): void {\n        this._result = evaluateCondition(this._condition, this._gameState.hand, this._gameState.deck.deckList);\n    }\n\n    serialise(): SerialisedSimulationBranch {\n        return {\n            result: this.result,\n            gameState: this._gameState.serialise(),\n            condition: serialiseCondition(this._condition)\n        }\n    }\n\n    static deserialise(serialisedBranch: SerialisedSimulationBranch): SimulationBranch {\n        const gameState = GameState.deserialize(serialisedBranch.gameState);\n        const condition = deserialiseCondition(serialisedBranch.condition);\n        const branch = new SimulationBranch(gameState, condition);\n        branch._result = serialisedBranch.result;\n        return branch;\n    }\n\n    get result(): boolean {\n        return this._result; \n    }\n\n    get condition(): Readonly<BaseCondition> {\n        return this._condition;\n    }\n\n    get gameState(): GameState {\n        return this._gameState;\n    }\n\n}\n\n/** Represents a single simulation run */\nexport class Simulation {\n    private _gameState: GameState;\n    private _branches: Map<BaseCondition, SimulationBranch[]> = new Map();\n    private _conditions: BaseCondition[];\n\n    /**\n     * Creates a new Simulation\n     * @param gameState - The initial game state\n     * @param _condition - The condition to evaluate\n     */\n    public constructor(gameState: GameState, conditions: BaseCondition[]) {\n        this._gameState = gameState.deepCopy();\n        this._conditions = conditions\n    }\n\n    private runBranch(branch: SimulationBranch): void {\n        branch.run();\n        \n        if (!this._branches.has(branch.condition)) {\n            this._branches.set(branch.condition, []);\n        }\n\n        const branches = this._branches.get(branch.condition) || [];\n        branches.push(branch);\n    }\n\n    /** Runs the simulation, evaluating the condition against the game state */\n    iterate(): void {\n        this._conditions.forEach(condition => {\n           // Run a branch with the original game state\n            const branch = new SimulationBranch(this._gameState, condition);\n            this.runBranch(branch);\n            if (this.result) return;    // return if branch succeeds, we won.\n\n            // The gamestate doesn't work, so we need to try all possible branches\n            this.generateFreeCardPermutations(this._gameState, condition); \n        });\n    }\n\n    private generateFreeCardPermutations(gameState: GameState, condition: BaseCondition, usedCards: FreeCard[] = []): void {\n        const freeCards = gameState.freeCardsInHand.filter(card => \n            freeCardIsUsable(gameState, card) && !usedCards.includes(card)\n        );\n\n        if (freeCards.length === 0) {\n            return;\n        }\n\n        for (const freeCard of freeCards) {\n            if (!freeCardIsUsable(gameState, freeCard)) {\n                continue;\n            }\n\n            // Create a new branch with the updated game state\n            const newGameState = gameState.deepCopy();\n            const branch = new SimulationBranch(newGameState, condition);\n            processFreeCard(branch, freeCard);\n            this.runBranch(branch);\n\n            if (this.result) return;  // If we've found a winning combination, stop searching\n\n            // Recursively generate permutations with the remaining free cards\n            this.generateFreeCardPermutations(branch.gameState, condition, [...usedCards, freeCard]);\n        }\n    }\n\n    public serialise(): SerialisedSimulation {\n        return {\n            gameState: this._gameState.serialise(),\n            conditions: this._conditions.map(serialiseCondition),\n            branches: Array.from(this._branches).map(([, branches]) => branches.map(branch => branch.serialise())).flat()\n        }\n    }\n\n    public static deserialise(serialisedSimulation: SerialisedSimulation): Simulation {\n        const gameState = GameState.deserialize(serialisedSimulation.gameState);\n        const conditions = serialisedSimulation.conditions.map(deserialiseCondition);\n        const simulation = new Simulation(gameState, conditions);\n\n        const branches = serialisedSimulation.branches.map(SimulationBranch.deserialise)\n        for (const branch of branches) {\n            if (!simulation._branches.has(branch.condition)) {\n                simulation._branches.set(branch.condition, []);\n            }\n            simulation._branches.get(branch.condition)?.push(branch);\n        }\n\n        return simulation;\n    }\n\n    /** Gets the result of the simulation */\n    public get result(): boolean {\n        return this.successfulBranches.some(([, branch]) => \n            {\n                const result = branch !== undefined && branch.result;\n                if (result) {\n                    console.log(branch);\n                }\n\n                return result;\n            });\n    }\n\n    /** Gets the conditions being evaluated */\n    public get conditions(): BaseCondition[] {\n        return this._conditions;\n    }\n\n    /** Gets the game state used in the simulation */\n    public get gameState(): GameState {\n        return this._gameState;\n    }\n\n    /** Gets the branches of the simulation */\n    public get branches(): Map<BaseCondition, SimulationBranch[]> {\n        return this._branches;\n    }\n\n    /** Get the branch that succeeded */\n    public get successfulBranches(): [BaseCondition, SimulationBranch | undefined][] {\n        return Array.from(this._branches).map(([condition, branches]) => [condition, branches.find(branch => branch.result)]) as [BaseCondition, SimulationBranch | undefined][];\n    }\n\n    /** Get the branches that failed */\n    public get failedBranches(): [BaseCondition, SimulationBranch[] | undefined][] {\n        return Array.from(this._branches).map(([condition, branches]) => [condition, branches.find(branch => !branch.result)]) as [BaseCondition, SimulationBranch[] | undefined][];\n    }\n}\n\nexport function runSimulation(gameState: GameState, conditions: BaseCondition[]): Simulation {\n    const simulation = new Simulation(gameState, conditions);\n    simulation.iterate();\n    return simulation;\n}\n","import { SerialisedSimulation, Simulation } from '../utils/simulation';\nimport { GameState } from '../utils/game-state';\nimport { buildDeck } from '../utils/deck';\nimport { CardDetails } from '../utils/card-details';\nimport { parseCondition } from '../utils/parser';\n\nexport interface SimulationWorkerMessage {\n    cards: Map<string, CardDetails>;\n    conditions: string;\n    handSize: number;\n    batchSize: number;\n}\n\nself.onmessage = (event: MessageEvent) => {\n    const { cards, conditions, handSize, batchSize } = event.data as SimulationWorkerMessage;\n    const serialisedSimulations: SerialisedSimulation[] = [];\n\n    console.log(`Running simulation with ${batchSize} batches of ${handSize} hands`);\n\n    for (let i = 0; i < batchSize; i++) {\n        const deck = buildDeck(new Map(cards));\n        const parsedConditions = (JSON.parse(conditions) as string[]).map(parseCondition);\n\n        const gamestate = new GameState(deck);\n        gamestate.drawHand(handSize);\n\n        const simulation = new Simulation(gamestate.deepCopy(), parsedConditions);\n        simulation.iterate();\n\n        serialisedSimulations.push(simulation.serialise());\n    }\n\n    self.postMessage(JSON.stringify(serialisedSimulations));\n};"],"names":["_arrayLikeToArray","r","a","length","e","n","Array","_unsupportedIterableToArray","t","toString","call","slice","constructor","name","from","test","_slicedToArray","isArray","l","Symbol","iterator","i","u","f","o","next","Object","done","push","value","TypeError","_toConsumableArray","_classCallCheck","_typeof","prototype","toPropertyKey","toPrimitive","String","_defineProperties","enumerable","configurable","writable","defineProperty","key","_createClass","_defineProperty","_getPrototypeOf","setPrototypeOf","getPrototypeOf","bind","__proto__","_setPrototypeOf","CostType","ConditionType","RestrictionType","ReferenceError","Card","cardName","cardDetails","this","_name","_details","_tags","tags","get","toLowerCase","FreeCard","_Card2","_callSuper","create","_inherits","details","free","count","oncePerTurn","_this$details$free","restriction","_this$details$free$co","_this$details$free2","cost","_this$details$free$co2","_this$details$free3","condition","_this$details$free$ex","_this$details$free4","excavate","_this$cost","type","BanishFromDeck","BanishFromHand","Discard","PayLife","CreateCard","Deck","cards","deckSize","arguments","undefined","missingCount","apply","fill","_cards","shuffle","newDeck","map","card","_objectSpread","Error","pop","randomFn","Math","random","j","floor","_ref","_this$_cards","buildDeck","deckList","_step","_iterator","_createForOfIteratorHelper","s","_details$qty","_step$value","qty","err","parseCondition","conditions","tokens","current","walk","GetLocationToken","token","LocationConditionTarget","Hand","nextToken","quantity","parseInt","operator","includes","location","Condition","result","parseExpression","SyntaxError","concat","lastToken","hasParentheses","left","right","AndCondition","OrCondition","parse","input","isLocationToken","match","tokenizeQuantity","NUMBERS","char","tokenizeName","NAME_CHARS","RegExp","source","isANDToken","isORToken","trim","tokenizeLocation","last_token","tokenize","serialiseCondition","successes","failures","deserialiseCondition","serialisedCondition","recordSuccess","recordFailure","getMatchingCards","cardList","filter","_successes","_failures","hand","_this","_hand","_requiredCards","index","findIndex","splice","operatorToSign","some","console","error","deck","_this2","currentCondition","remainingConditions","getPossibleCombinations","_ret","_loop","usedCards","remainingHand","checkCombinations","v","matchingCards","getCombinations","tempGameState","evaluateCondition","requiredCards","k","_this3","combinations","_loop2","head","forEach","tailCombo","Set","c","join","flatMap","cardsUsed","checkCondition","success","evaluate","evaluateSimpleCondition","_result$usedCards","ret","evaluateAndCondition","evaluateOrCondition","_step2","permutations","permute","arr","start","_ref2","generateHandPermutations","_iterator2","freeCardIsUsable","gameState","cardsPlayedThisTurn","usedCard","deckCount","activationCount","freeCardsPlayedThisTurn","_usedCard$restriction","restrictions","NoMoreDraws","NoSpecialSummon","NoPreviousDraws","checkCardRestrictions","handLessCard","handCard","cardCanPayCost","countMetConditions","localGameState","deepCopy","processFreeCard","simulation","freeCard","find","cardInHand","_gameState$hand2","playCard","banishFromHand","drawCard","availableCards","cardsToRemove","_cardsToRemove","requirements","_c$tags","discardFromHand","payCost","_gameState$hand","_card$excavate","pick","excavatedCards","baseScore","sortedCards","sort","b","aScore","addToBottom","requirement","cardToRemove","_c$tags2","payPostConditions","handleFreeCard","GameState","_deck","newState","_banishPile","_graveyard","banishPile","graveyard","handSize","isFree","_cardsPlayed","_this$_graveyard","_this$_banishPile","serialisedGameState","Map","SimulationBranch","_gameState","_result","_condition","serialise","serialisedBranch","branch","deserialize","Simulation","_conditions","run","_branches","has","set","runBranch","generateFreeCardPermutations","freeCards","freeCardsInHand","newGameState","branches","flat","successfulBranches","_ref3","log","_ref5","_ref6","_ref7","_ref8","serialisedSimulation","deserialise","_simulation$_branches","self","onmessage","event","data","batchSize","serialisedSimulations","parsedConditions","JSON","gamestate","drawHand","iterate","postMessage","stringify"],"sourceRoot":""}